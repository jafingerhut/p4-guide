# Introduction

Caveat emptor: I do not claim to have encyclopedic knowledge of TCP
options, nor to have ever written TCP option parsing code "for real",
i.e. as part of a project where I was responsible for deploying it
into production use, and fixing bugs that arose due to errors or
omissions.  People who do that tend to learn all kinds of details that
I have not.

The P4_16 program `look-for-ts-tcp-option.p4` in this directory has
several `#include` preprocessor directives.  Those files contain very
repetitive code that can be generated by running the Python program
`generate.py`.  See the [`code-generation`](/code-generation/)
directory for an introduction to this technique, if you are not
familiar with it.

The goal with this program is:

+ Look for a TCP Timestamp option in packets that begin with an
  Ethernet, then IPv4, then TCP header.
+ If one is found, extract its fields into some P4 variables.  These
  variables can then be processed however you wish, if you write the
  P4 code to do it.

Below is some code that implements the first step above.  It is
written in C, or something very close to it (I have not checked
whether it compiles using a C compiler).  I would not call it brief,
but hopefully it is at least clear how it behaves, to anyone with at
least some familiarity with C-like programming languages (e.g. C++,
Java, even Python knowledge should help you understand most of it
without trouble).

I do not see any way to make that code significantly shorter or
simpler, and yet still accomplish the task that it does.  One could
simplify it a bit by accomplishing a simpler task, for example: "find
the TCP Timestamp option, but only if it appears as the first TCP
option, except perhaps skip over up to 2 NOP options if they appear
before the Timestamps option".

It _is_ shorter than the P4 version of the code that is generated to
behave like this code, because the code below takes advantage of
a `while` loop and an array of bytes (type `uint8_t`) called
`tcp_options` that can be indexed at a byte offset that is a run-time
variable.

```
// See this document for a longer list of TCP options that have been
// proposed.  I do not know exactly which of them are in common use,
// but I believe all of the ones listed here are commonly used.  There
// might be others not included here that are also commonly used, and
// I simply do not know that.

// "Transmission Control Protocol (TCP) Parameters", Last updated
// 2019-07-26,
// https://www.iana.org/assignments/tcp-parameters/tcp-parameters.xhtml

#define TCP_OPTION_END_OF_OPTIONS 0    // End of Option List - RFC 793
#define TCP_OPTION_NOP            1    // No-Operation - RFC 793
#define TCP_OPTION_MSS            2    // Maximum Segment Size - RFC 793
#define TCP_OPTION_WINDOW_SCALE   3    // Window Scale - RFC 7323
#define TCP_OPTION_SACK_PERMITTED 4    // SACK Permitted - RFC 2018
#define TCP_OPTION_SACK           5    // SACK - RFC 2018
#define TCP_OPTION_TIMESTAMPS     8    // Timestamps - RFC 7323


    // Inputs expected to be initialized before this code executes.
    uint8_t tcp_options[40];
    int options_length = (hdr.tcp.dataOffset << 2) - 20;
    // Assume that hdr.tcp.dataOffset has already been checked that it
    // is at least 5, so options_length is guaranteed to be a multiple
    // of 4 in the range [0, 40].

    // Output values
    bool found_ts_option = FALSE;
    int offset = 0;

    // temporary variables
    uint8_t option_kind;
    bool known_option;
    bool kind_followed_by_length;
    bool fixed_length;
    uint8_t expected_fixed_length;
    uint8_t option_len_bytes;

    while (offset < options_length) {
        option_kind = tcp_options[offset];
        // See definition of get_option_kind_info below.  Given a TCP
        // option kind byte value, it determines whether that option
        // kind is known to this implementation, whether there
        // should be a length byte following the kind byte, whether
        // the option is fixed or variable length, and if fixed
        // length, what length it should be.
        get_option_kind_info(option_kind, &known_option,
                      &kind_followed_by_length, &fixed_length,
                      &expected_fixed_length);
        if (!known_option) break;
        if (kind_followed_by_length) {
            if ((offset + 1) >= options_length) {
                // malformed TCP options - fell off end of TCP options header
                break;
            }
            option_len_bytes = tcp_options[offset+1];
            if (fixed_length && (option_len_bytes != expected_fixed_length)) {
                // malformed TCP options - incorrect length
                break;
            }
            // This code assumes that if fixed_length is FALSE, the
            // length in the packet is correct.  For the SACK option,
            // it is possible to check that the option length is one
            // of a few legal values.  See parser state
            // 'parse_tcp_options_sack' in the program
            // tcp-options-parser.p4 for some details on this.
        } else {
            option_len_bytes = 1;
        }
        if ((offset + option_len_bytes) > options_length) {
            // option is too long to fit in packet's TCP options
            break;
        }
        // This code stops when the first Timestamps option is found.
        if (option_kind == TCP_OPTION_TIMESTAMPS) {
            found_ts_option = TRUE;
            break;
        }
        if (option_kind == TCP_OPTION_END_OF_OPTIONS) {
            // Stop if End of Options option is encountered.
            break;
        }
        offset = offset + option_len_bytes;
    }

    // Now if found_ts_option is TRUE, it should begin at the byte
    // offset in the variable 'offset'.  Otherwise, it could be that
    // some other TCP option not recognized by get_option_kind_info()
    // was encountered, and there really is a Timestamp option in the
    // packet, after that unrecognized one.

    if (found_ts_option) {
        // get_uint32_at_byte_offset is defined below, and simply gets
        // 4 consecutive bytes and appends them together into a 32-bit
        // unsigned integer, in network byte order (i.e big endian,
        // most significant byte first).
        uint32_t TSval = get_uint32_at_byte_offset(tcp_options, offset + 2);
        uint32_t TSecr = get_uint32_at_byte_offset(tcp_options, offset + 6);

        // Do anything else here that you want with the TSval and
        // TSecr values.
    }

get_option_kind_info (uint8_t in_option_kind,
                      bool *out_known_option,
                      bool *out_kind_followed_by_length,
                      bool *out_fixed_length,
                      uint8_t *out_expected_fixed_length)
{
    *out_known_option = TRUE;
    switch (in_option_kind) {
    case TCP_OPTION_END_OF_OPTIONS:
        *out_kind_followed_by_length = FALSE;
        break;
    case TCP_OPTION_NOP:
        *out_kind_followed_by_length = FALSE;
        break;
    case TCP_OPTION_MSS:
        *out_kind_followed_by_length = TRUE;
        *out_fixed_length = TRUE;
        *out_expected_fixed_length = 4;
        break;
    case TCP_OPTION_WINDOW_SCALE:
        *out_kind_followed_by_length = TRUE;
        *out_fixed_length = TRUE;
        *out_expected_fixed_length = 4;
        break;
    case TCP_OPTION_SACK_PERMITTED:
        *out_kind_followed_by_length = TRUE;
        *out_fixed_length = TRUE;
        *out_expected_fixed_length = 2;
        break;
    case TCP_OPTION_SACK:
        *out_kind_followed_by_length = TRUE;
        *out_fixed_length = FALSE;
        break;
    case TCP_OPTION_TIMESTAMPS:
        *out_kind_followed_by_length = TRUE;
        *out_fixed_length = TRUE;
        *out_expected_fixed_length = 10;
        break;
    default:
        *out_known_option = FALSE;
        break;
    }
}

uint32_t get_uint32_at_byte_offset(uint8_t in_tcp_options[],
                                   int in_byte_offset)
{
    int i = in_byte_offset;
    uint32 ret;

    ret = ((((uint32_t) in_tcp_options[i+0]) << 24) |
           (((uint32_t) in_tcp_options[i+1]) << 16) |
           (((uint32_t) in_tcp_options[i+2]) <<  8) |
           (((uint32_t) in_tcp_options[i+3]) <<  0));
    return ret;
}

```

My P4 version of this code "unrolls" the loop to some maximum number
of iterations that you can change if you wish, and avoids using
run-time variable array indexes.  Both of those results are achieved
in the same way as demonstrated in the example programs in the
[`code-generation`](/code-generation/) directory.

One choice you can make in using this unroll-the-loop technique is the
maximum number of iterations to execute.  I doubt that any TCP
implementations in common use create 40 bytes of options that consist
of 30 1-byte NOP options (a single byte equal to 1), followed by a
10-byte long Timestamps option, and this might even be prohibited by
some RFC somewhere that I have not read.  If it is not prohibited, it
appears legal to create such a packet.  The code above would repeat
the while loop body 31 times before it would find the Timestamps
option.

On some high speed P4 implementations, you might not be willing (or
able) to use the P4 version of the code that unrolls the loop 31
times.  You may be willing to make an engineering tradeoff such as:
unroll the loop only 8 times, and if the P4 program does not find the
Timestamps option in 8 iterations, it is acceptable not to process the
Timestamps option in that packet.

To change the maximum number of iterations to any number 1 or larger,
edit the file `compile.sh`, and replace the 8 on the following line
with the number of iterations you wish to use:
```bash
../generate.py --num-parse-iterations 8
```

Unlike some of the other example P4 programs in this repository
dealing with parsing TCP options, this one uses neither header stacks
nor any `header_union` type.  This is simply to demonstrate a
different way to do it -- one that might be more portable to different
P4 implementations.  There are other ways to achieve the goal besides
the examples in this repository -- do not take the lack of yet another
style of P4 program as me claiming "it cannot be done any other way"
-- it certainly can be [2].


# References

[1]

Documents, especially RFCs, examined while writing this example code
(perhaps only briefly -- no claim of complete, nor even thorough,
knowledge is made here).

"Transmission Control Protocol (TCP) Parameters", Last updated
2019-07-26,
https://www.iana.org/assignments/tcp-parameters/tcp-parameters.xhtml

RFC 793, "Transmission Control Protocol", September 1981,
https://tools.ietf.org/html/rfc793

RFC 7323, "TCP Extensions for High Performance", September 2014,
https://tools.ietf.org/html/rfc7323


[2]

One could use techniques similar to a Kangaroo parser (see below) in
the ingress control to reduce the number of dependent iterations
required to get to the timestamp option, at least for some sequences
of TCP options, making the code easier to "fit" into certain P4
targets, with the tradeoff that the code is a bit more complex to
understand and maintain.

This suggestion might sound confusing.  You may be wondering: don't P4
implementations often use techniques like Kangaroo parsers in their
implementation of a P4 `parser` construct?  Yes, very like some
implementations use that technique.  My note that you could write code
using that technique in a P4 `control` may sound odd, but there
_might_ be situations where it is desirable to do.  It can be useful
to know about multiple options if one is working under tight
constraints.

+ "Leaping multiple headers in a single bound: wire-speed parsing
  using the Kangaroo system", Christos Kozanitis, John Huber, Sushil
  Singh, George Varghese,
  http://cseweb.ucsd.edu/~ckozanit/files/infocom2010.pdf
